# 快看是(:例题)

---



## <mark>排队接水</mark>

知识点：

`下标索引的理解`,选择排序，原始编号移动，前缀和  

![loading-ag-77](./images/屏幕截图%202025-11-05%20212756.png)

解答：

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    double time[n];
    int original_index[n];//设立原始编号，很重要
    for(int i = 0;i<n;i++){
        cin>>time[i];
        original_index[i] = i+1;
    }
    for(int i = 0;i<n;i++){
        int minindex = i;
        for(int j = i+1;j<n;j++){
            if(time[j]<time[minindex]){//利用选择排序从小到大选出索引，完成第一行输出
                minindex = j;
            }
        }
        cout<<original_index[minindex]<<" ";
        swap(time[i],time[minindex]);//防止重复，还是需要交换元素
        swap(original_index[i],original_index[minindex]);//原始编号也要跟着它主人一起移动交换
    }
    cout<<endl;
    double sum = 0;

    double pre[n];//计算每个人除了自己接水，需要额外等待的时间
    pre[0] = 0;//第一个人额外等待时间为0
    for(int i = 1;i<n;i++){//从第二个人开始
        pre[i] = time[i-1]+pre[i-1];//等于他前一个人接水时间加上前一个人额外等待时间
    }

    for(int i = 0;i<n;i++){//计算等待总时间
        sum = sum+pre[i];//修改为正确的等待时间
    }
    double average = sum/n;
    cout<<fixed<<setprecision(3)<<average;
    return 0;
}
```

重点在于原始编号按题目要求改变后，能够正确输出

---

## <mark>自然数的拆分</mark>

知识点：

`深度优化搜索DFS`,全局变量，一些语法和编程习惯

![自然数拆分题目](./images/ced8316371f1749082576d431c9e8374.jpg)

解法：

```c++
#include <bits/stdc++.h>
using namespace std;
vector<string> results;//设置全局变量
void dfs(int remain,int start,string current){
    if(remain==0){
        results.push_back(current);//如果remain已经为0，说明完成一种拆分方法，将它存入results
        return;
    }
    for(int i = start;i<=remain;i++){//先从从1到n选一个数
        string new_current;//开一个新的拆分方法
        if(current.empty()){
            new_current = to_string(i);
        }else{
            new_current = current+"+"+to_string(i);
        }
        dfs(remain-i,i,new_current);//相当于，例如n=7，已经选了一个1，再考虑剩下的6怎么拆......
    }
}
int main(){
    int n;
    cin>>n;
    dfs(n,1,"");//读入
    sort(results.begin(),results.end());//按字典序升序排列（题目要求）
    for(int i = 0;i<results.size();i++){
        if(results[i]==to_string(n)){//去掉最后的n=n
            results.erase(results.begin()+i);//erase必须要访问变量的地址，不能用results[i]
            i--;//此题其实不需要i--，但是如果有多个n=n就需要，保持好习惯
        }
    }
    for(int i = 0;i<results.size();i++){
        cout<<n<<"="<<results[i]<<endl;
    }
    return 0;
}
```

**全局变量**在main（）函数外，所有函数都可以直接使用这个变量

细节很多，慢慢品......

---

## <mark>暴龙的白菜</mark>

知识点：预留空间，`+=`的好处，字符到数值的前缀和

题目：

![暴龙的白菜](./images/屏幕截图%202025-11-09%20221605.png)

解法：

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int main(){
    string s;
    s.reserve(1000005);
    for(int i = 1;s.size()<=1e6;i++){
        string temp = to_string(i);
        for(int j = 1;j<=i;j++){
            s += temp;//完成这个大字符串创建
        }
    }
    int t;
    cin>>t;
    ll presum[1000005] = {0};
    for(ll i = 1;i<=1e6;i++){
        presum[i] = presum[i-1]+(s[i-1]-'0');//甜菜前缀和，直接把字符转换为数值了
    }
    while(t--){
        ll l,r;
        cin>>l>>r;
        ll sum = presum[r]-presum[l-1];
        cout<<sum<<endl;
    }
}
```

---

## <mark>求f的表达式</mark>

知识点：递归函数入门

题目：

![f表达式](./images/屏幕截图%202025-11-11%20091222.png)

解法：

```c++
#include <bits/stdc++.h>
using namespace std;
double f(double x, int n, int m) {//基本的递归写法，常看常新哦
    double result = sqrt(m + x);
    if (m < n) {
        return f(result, n, m + 1);
    } else {
        return result;
    }
}
int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        double x;
        int n;
        scanf("%lf %d", &x, &n);
        double result = f(x, n, 1);//每次从m=1开始
        printf("%.3f\n", result);
    }
    return 0;
}
```



---

## <mark>活动的选择</mark>

知识点：贪心，区间衔接，sort排序

题目：

![活动的选择](./images/屏幕截图%202025-11-11%20091202.png)

解法：

```c++
#include <bits/stdc++.h>
using namespace std;
struct timeq{
    int begin;
    int end;
};
int main(){
    int n;
    cin>>n;
    vector<timeq> activ(n);
    for(int i = 0;i<n;i++){
        cin>>activ[i].begin>>activ[i].end;
    }
    for(int i = 0;i<n-1;i++){
        for(int j = 0;j<n-1-i;j++){
            if(activ[j].end>activ[j+1].end){
                swap(activ[j],activ[j+1]);//按结束时间从早到晚排序，结束越早的排前面，最后能够排更多个数
            }
        }
    }
    int cnt = 1;
    for(int i = 0;i<n;){
        int j = i+1;
        while(j<n && activ[i].end>activ[j].begin){//从第一个最早结束的活动开始，向后寻找第一个匹配的活动
            j++;
        }
        //此刻在while结束后找到了一个j
        if(j<=n-1){
            cnt++;
            i = j;
        }else{
            break;//若j已经超出活动数量n，直接结束就可以了
        }
    }
    cout<<cnt;
    return 0;
}
```

---

## <mark>2的幂次方表示</mark>







解法：

```c++
#include <bits/stdc++.h>
using namespace std;
string solve(int n){
    if(n==1)return "2(0)";//雷霆递归（哭
    if(n==2)return "2";
    string result = "";
    for(int power = 14;power>-1;power--){
        int two_power = 1;
        for(int j = 0;j<power;j++){
            two_power = two_power*2;
        }
        if(n>=two_power){
            if(result!=""){
                result += "+";
            }
            if(power==1){
                result += "2";
            }else if(power==0){
                result += "2(0)";
            }else{
                result += "2("+solve(power)+")";
            }
            n -= two_power;
        }
    }
    return result;
}
int main(){
    int t;
    cin>>t;
    while(t--){
        int n;
        cin>>n;
        cout<<solve(n)<<endl;
    }
    return 0;
}
```
